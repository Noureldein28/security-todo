# ğŸ”’ SecureTodo - ASP.NET Core 8.0 Implementation

A full-stack secure todo application built with ASP.NET Core 8.0, demonstrating enterprise-grade security practices including AES-256-GCM encryption, SHA-256 integrity verification, JWT authentication with refresh tokens, and comprehensive security middleware.

## ğŸ“‹ Table of Contents

- [Features](#features)
- [Architecture](#architecture)
- [Security Implementation](#security-implementation)
- [Prerequisites](#prerequisites)
- [Installation](#installation)
- [Configuration](#configuration)
- [Running the Application](#running-the-application)
- [API Documentation](#api-documentation)
- [Comparison with Node.js Version](#comparison-with-nodejs-version)
- [Troubleshooting](#troubleshooting)

## âœ¨ Features

### User Authentication
- Email/password registration and login
- Google OAuth 2.0 Single Sign-On (SSO) support
- JWT-based authentication with access and refresh tokens
- HTTP-only secure cookies for token storage
- Password strength validation with BCrypt hashing (12 rounds)

### Todo Management
- Create, read, update, and delete todos
- All todo content encrypted at rest with AES-256-GCM
- Real-time integrity verification using SHA-256 hashing
- Tamper detection and notification

### Security Features
- **Encryption**: AES-256-GCM for data at rest
- **Integrity**: SHA-256 hashing for tamper detection
- **Authentication**: JWT with HS256 signing
- **Password Hashing**: BCrypt with 12 rounds
- **Rate Limiting**: Configurable per-endpoint limits
- **Input Validation**: FluentValidation with comprehensive rules
- **Security Headers**: CSP, X-Frame-Options, HSTS, etc.
- **Logging**: Serilog with file and console output
- **Exception Handling**: Global error handler with proper HTTP status codes

## ğŸ—ï¸ Architecture

This application follows **Clean Architecture** principles with clear separation of concerns:

```
SecureTodo.sln
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ SecureTodo.API/              # Web API Layer - Controllers, Middleware
â”‚   â”œâ”€â”€ SecureTodo.Application/      # Business Logic - Services, DTOs, Validators
â”‚   â”œâ”€â”€ SecureTodo.Domain/           # Domain Models - Entities, Interfaces
â”‚   â”œâ”€â”€ SecureTodo.Infrastructure/   # Data Access - EF Core, Repositories, Security
â”‚   â””â”€â”€ SecureTodo.Shared/           # Shared Code - Constants, Results, Exceptions
â””â”€â”€ README.md
```

### Layer Dependencies

```
API â†’ Application â†’ Infrastructure â†’ Domain
API â†’ Shared
Application â†’ Shared
```

**Key Principles:**
- Domain has NO dependencies (pure business logic)
- Infrastructure depends only on Domain
- Application orchestrates Domain and Infrastructure
- API is the entry point and presentation layer

## ğŸ” Security Implementation

### 1. AES-256-GCM Encryption

**Implementation**: `SecureTodo.Infrastructure/Security/CryptoService.cs`

```csharp
// Encrypt todo content before storage
var (encryptedContent, iv, authTag) = cryptoService.Encrypt(plaintext);

// Decrypt on retrieval
var plaintext = cryptoService.Decrypt(encryptedContent, iv, authTag);
```

**Details:**
- **Algorithm**: AES (Advanced Encryption Standard) with 256-bit key
- **Mode**: GCM (Galois/Counter Mode) - provides authenticated encryption
- **Key**: 32 bytes (256 bits), base64 encoded, stored in configuration
- **IV**: 12 bytes, randomly generated per encryption, never reused
- **Auth Tag**: 16 bytes, automatically generated by GCM mode

**Storage Format:**
```json
{
  "encryptedContent": "base64-encoded-ciphertext",
  "iv": "base64-encoded-12-byte-iv",
  "authTag": "base64-encoded-16-byte-auth-tag",
  "integrityHash": "sha256-hex-hash"
}
```

**Why GCM?**
- Provides both encryption and authentication (AEAD)
- Detects tampering automatically
- Better performance than CBC + HMAC
- Industry standard for modern encryption

### 2. SHA-256 Integrity Verification

**Implementation**: `SecureTodo.Infrastructure/Security/HashService.cs`

**Process:**
1. **Before Encryption**: Compute SHA-256 hash of plaintext â†’ Store hash
2. **After Decryption**: Compute SHA-256 hash of decrypted text â†’ Compare
3. **If Mismatch**: Flag as tampered, display warning

**Purpose:**
- Double-layer integrity (GCM auth tag + SHA-256 hash)
- Detects database manipulation
- Provides audit trail

### 3. BCrypt Password Hashing

**Implementation**: `SecureTodo.Infrastructure/Security/PasswordHasher.cs`

**Configuration:**
- Rounds: 12 (work factor)
- Salt: Automatically generated per password
- Library: BCrypt.Net-Next

```csharp
var hashedPassword = passwordHasher.HashPassword(plainPassword);
var isValid = passwordHasher.VerifyPassword(plainPassword, hashedPassword);
```

### 4. JWT Authentication

**Implementation**: `SecureTodo.Application/Services/JwtService.cs`

**Token Structure:**
- **Access Token**: 1 hour expiry, used for API requests
- **Refresh Token**: 7 days expiry, used to get new access tokens
- **Storage**: HTTP-only cookies (prevents XSS)
- **Signing**: HS256 with configurable secret key

**Claims:**
```json
{
  "nameid": "user-guid",
  "email": "user@example.com",
  "jti": "token-id",
  "exp": 1234567890,
  "iss": "SecureTodoAPI",
  "aud": "SecureTodoClient"
}
```

### 5. Rate Limiting

**Configuration**: `Program.cs` and `appsettings.json`

```csharp
// General endpoints: 60 requests/minute
// Auth endpoints: 10 requests/minute
```

**Implementation**: AspNetCoreRateLimit library
- IP-based limiting
- Per-endpoint configuration
- Memory cache for counters

### 6. Security Headers

**Middleware**: `SecureTodo.API/Middleware/SecurityHeadersMiddleware.cs`

```
Content-Security-Policy: default-src 'self'
X-Frame-Options: DENY
X-Content-Type-Options: nosniff
X-XSS-Protection: 1; mode=block
Referrer-Policy: strict-origin-when-cross-origin
```

### 7. Input Validation

**Implementation**: FluentValidation

**Example:**
```csharp
RuleFor(x => x.Password)
    .NotEmpty()
    .MinimumLength(8)
    .Matches("[A-Z]") // uppercase required
    .Matches("[a-z]") // lowercase required
    .Matches("[0-9]"); // digit required
```

## ğŸ“¦ Prerequisites

- **.NET 8.0 SDK** or later ([Download](https://dotnet.microsoft.com/download))
- **SQL Server** or **SQL Server Express** ([Download](https://www.microsoft.com/sql-server/sql-server-downloads))
  - Alternatively: SQL Server LocalDB (included with Visual Studio)
- **Visual Studio 2022** or **VS Code** (optional but recommended)
- **Git** for version control

## ğŸš€ Installation

### Step 1: Clone the Repository

```bash
git clone <repository-url>
cd security-todo
```

### Step 2: Navigate to Source Directory

```bash
cd src
```

### Step 3: Restore Dependencies

```bash
dotnet restore
```

This will restore all NuGet packages for all projects in the solution.

## âš™ï¸ Configuration

### Step 1: Generate Encryption Keys

**For JWT Secret (64 bytes):**
```bash
# Using PowerShell (Windows)
[Convert]::ToBase64String((1..64 | ForEach-Object { Get-Random -Minimum 0 -Maximum 256 }))

# Using OpenSSL (Linux/Mac/Git Bash)
openssl rand -base64 64

# Using .NET CLI
dotnet user-secrets set "JwtSettings:SecretKey" "$(openssl rand -base64 64)" -p SecureTodo.API
```

**For AES Key (32 bytes):**
```bash
# Using PowerShell
[Convert]::ToBase64String((1..32 | ForEach-Object { Get-Random -Minimum 0 -Maximum 256 }))

# Using OpenSSL
openssl rand -base64 32

# Using .NET CLI
dotnet user-secrets set "EncryptionSettings:AesKey" "$(openssl rand -base64 32)" -p SecureTodo.API
```

### Step 2: Configure Database Connection

Edit `src/SecureTodo.API/appsettings.Development.json`:

**For SQL Server LocalDB (default):**
```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=(localdb)\\mssqllocaldb;Database=SecureTodoDB;Trusted_Connection=true;MultipleActiveResultSets=true;TrustServerCertificate=true"
  }
}
```

**For SQL Server Express:**
```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=localhost\\SQLEXPRESS;Database=SecureTodoDB;Trusted_Connection=true;MultipleActiveResultSets=true;TrustServerCertificate=true"
  }
}
```

**For Azure SQL:**
```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=tcp:yourserver.database.windows.net,1433;Initial Catalog=SecureTodoDB;Persist Security Info=False;User ID=yourusername;Password=yourpassword;MultipleActiveResultSets=True;Encrypt=True;TrustServerCertificate=False;"
  }
}
```

### Step 3: Update Configuration Keys

Edit `src/SecureTodo.API/appsettings.Development.json` and replace placeholder keys:

```json
{
  "JwtSettings": {
    "SecretKey": "YOUR_GENERATED_JWT_SECRET_HERE"
  },
  "EncryptionSettings": {
    "AesKey": "YOUR_GENERATED_AES_KEY_HERE"
  }
}
```

### Step 4: Configure Google OAuth (Optional)

1. Go to [Google Cloud Console](https://console.cloud.google.com/)
2. Create a new project
3. Enable Google+ API
4. Create OAuth 2.0 credentials
5. Add authorized redirect URI: `https://localhost:7000/api/auth/google-callback`
6. Update `appsettings.json`:

```json
{
  "GoogleAuth": {
    "ClientId": "your-google-client-id.apps.googleusercontent.com",
    "ClientSecret": "your-google-client-secret"
  }
}
```

### Step 5: Apply Database Migrations

```bash
cd src
dotnet ef database update -p SecureTodo.Infrastructure -s SecureTodo.API
```

This will create the database and all required tables.

## ğŸ¯ Running the Application

### Development Mode

```bash
cd src/SecureTodo.API
dotnet run
```

Or using the solution:

```bash
cd src
dotnet run --project SecureTodo.API
```

The application will start on:
- HTTPS: `https://localhost:7000`
- HTTP: `http://localhost:5000`

### Access Swagger UI

Navigate to: `https://localhost:7000/swagger`

### Using Visual Studio

1. Open `src/SecureTodo.sln`
2. Set `SecureTodo.API` as the startup project
3. Press F5 to run with debugging

## ğŸ“š API Documentation

### Base URL
```
https://localhost:7000/api
```

### Authentication Endpoints

#### Register User
```http
POST /api/auth/register
Content-Type: application/json

{
  "username": "johndoe",
  "email": "john@example.com",
  "password": "SecurePass123"
}
```

**Response:**
```json
{
  "success": true,
  "data": {
    "accessToken": "eyJhbGc...",
    "refreshToken": "base64-token...",
    "user": {
      "id": "guid",
      "username": "johndoe",
      "email": "john@example.com",
      "createdAt": "2024-01-01T00:00:00Z"
    }
  },
  "message": "User registered successfully"
}
```

#### Login
```http
POST /api/auth/login
Content-Type: application/json

{
  "email": "john@example.com",
  "password": "SecurePass123"
}
```

#### Refresh Token
```http
POST /api/auth/refresh
Content-Type: application/json

{
  "refreshToken": "your-refresh-token"
}
```

#### Logout
```http
POST /api/auth/logout
Authorization: Bearer your-jwt-token
```

### Todo Endpoints

All todo endpoints require authentication via JWT token.

#### Get All Todos
```http
GET /api/todos
Authorization: Bearer your-jwt-token
```

**Response:**
```json
{
  "success": true,
  "data": [
    {
      "id": "guid",
      "content": "Buy groceries",
      "tampered": false,
      "createdAt": "2024-01-01T00:00:00Z",
      "updatedAt": "2024-01-01T00:00:00Z"
    }
  ]
}
```

#### Get Todo by ID
```http
GET /api/todos/{id}
Authorization: Bearer your-jwt-token
```

#### Create Todo
```http
POST /api/todos
Authorization: Bearer your-jwt-token
Content-Type: application/json

{
  "content": "Buy groceries"
}
```

#### Update Todo
```http
PUT /api/todos/{id}
Authorization: Bearer your-jwt-token
Content-Type: application/json

{
  "content": "Buy groceries and cook dinner"
}
```

#### Delete Todo
```http
DELETE /api/todos/{id}
Authorization: Bearer your-jwt-token
```

### Standard Response Format

**Success:**
```json
{
  "success": true,
  "data": { ... },
  "message": "Operation successful",
  "errors": []
}
```

**Error:**
```json
{
  "success": false,
  "data": null,
  "message": "Operation failed",
  "errors": ["Error detail 1", "Error detail 2"]
}
```

## ğŸ”„ Comparison with Node.js Version

### Architecture

| Feature | Node.js | ASP.NET Core |
|---------|---------|--------------|
| **Architecture** | MVC pattern | Clean Architecture (4 layers) |
| **Language** | JavaScript | C# |
| **Framework** | Express.js | ASP.NET Core 8.0 |
| **Database** | MongoDB | SQL Server |
| **ORM** | Mongoose | Entity Framework Core |

### Security Features

| Feature | Node.js | ASP.NET Core | Status |
|---------|---------|--------------|--------|
| **AES-256-GCM** | âœ… crypto module | âœ… System.Security.Cryptography | âœ… Equivalent |
| **SHA-256 Hash** | âœ… crypto module | âœ… SHA256.HashData | âœ… Equivalent |
| **BCrypt (12 rounds)** | âœ… bcrypt | âœ… BCrypt.Net-Next | âœ… Equivalent |
| **JWT Auth** | âœ… jsonwebtoken | âœ… System.IdentityModel.Tokens.Jwt | âœ… Equivalent |
| **Refresh Tokens** | âœ… In-memory | âœ… Database-persisted | âœ… Improved |
| **Rate Limiting** | âœ… express-rate-limit | âœ… AspNetCoreRateLimit | âœ… Equivalent |
| **Input Validation** | âœ… express-validator | âœ… FluentValidation | âœ… Improved |
| **Logging** | âœ… Winston | âœ… Serilog | âœ… Equivalent |
| **Security Headers** | âœ… Helmet | âœ… Custom Middleware | âœ… Equivalent |

### Advantages of ASP.NET Core Version

âœ… **Type Safety**: Strong typing with C# prevents many runtime errors
âœ… **Dependency Injection**: Built-in DI container
âœ… **Clean Architecture**: Better separation of concerns
âœ… **Performance**: Generally faster than Node.js for I/O operations
âœ… **Async/Await**: Native support with better error handling
âœ… **EF Core**: Powerful ORM with migration support
âœ… **Swagger Integration**: Built-in API documentation
âœ… **Production-Ready**: Enterprise-grade framework

## ğŸ”§ Troubleshooting

### Database Connection Issues

**Problem**: Cannot connect to SQL Server

**Solutions**:
1. Verify SQL Server is running:
   ```bash
   # Windows
   Get-Service MSSQLSERVER
   
   # Or for SQL Express
   Get-Service MSSQL$SQLEXPRESS
   ```

2. Check connection string in `appsettings.Development.json`

3. Test connection using SQL Server Management Studio

### Migration Errors

**Problem**: `dotnet ef` command not found

**Solution**:
```bash
dotnet tool install --global dotnet-ef
```

**Problem**: Migration fails

**Solution**:
```bash
# Remove existing migrations
dotnet ef migrations remove -p SecureTodo.Infrastructure -s SecureTodo.API

# Create new migration
dotnet ef migrations add InitialCreate -p SecureTodo.Infrastructure -s SecureTodo.API

# Apply migration
dotnet ef database update -p SecureTodo.Infrastructure -s SecureTodo.API
```

### Encryption Key Errors

**Problem**: "AES_KEY is not configured"

**Solution**:
1. Generate a new key: `openssl rand -base64 32`
2. Add to `appsettings.Development.json`:
   ```json
   {
     "EncryptionSettings": {
       "AesKey": "YOUR_GENERATED_KEY"
     }
   }
   ```

### JWT Token Errors

**Problem**: "JWT SecretKey not configured"

**Solution**:
1. Generate a new secret: `openssl rand -base64 64`
2. Add to `appsettings.Development.json`:
   ```json
   {
     "JwtSettings": {
       "SecretKey": "YOUR_GENERATED_SECRET"
     }
   }
   ```

### Rate Limiting Issues

**Problem**: Getting 429 (Too Many Requests) immediately

**Solution**: Clear the memory cache or restart the application. Rate limits are stored in memory.

### Build Errors

**Problem**: "The type or namespace name could not be found"

**Solution**:
```bash
cd src
dotnet restore
dotnet build
```

## ğŸ“ Development Guide

### Adding a New Entity

1. Create entity in `SecureTodo.Domain/Entities/`
2. Add repository interface in `SecureTodo.Domain/Interfaces/`
3. Implement repository in `SecureTodo.Infrastructure/Repositories/`
4. Add DbSet to `ApplicationDbContext`
5. Create entity configuration in `SecureTodo.Infrastructure/Data/Configurations/`
6. Create migration: `dotnet ef migrations add AddNewEntity`

### Adding a New Endpoint

1. Create DTO in `SecureTodo.Application/DTOs/`
2. Create validator in `SecureTodo.Application/Validators/`
3. Add service interface in `SecureTodo.Application/Services/`
4. Implement service in `SecureTodo.Application/Services/`
5. Create controller action in `SecureTodo.API/Controllers/`
6. Test with Swagger UI

### Running Tests

```bash
cd src
dotnet test
```

## ğŸ“„ Project Structure Details

```
src/
â”œâ”€â”€ SecureTodo.API/
â”‚   â”œâ”€â”€ Controllers/             # API endpoints
â”‚   â”œâ”€â”€ Middleware/              # Custom middleware
â”‚   â”œâ”€â”€ Program.cs               # Application startup
â”‚   â””â”€â”€ appsettings.json         # Configuration
â”‚
â”œâ”€â”€ SecureTodo.Application/
â”‚   â”œâ”€â”€ DTOs/                    # Data Transfer Objects
â”‚   â”œâ”€â”€ Services/                # Business logic services
â”‚   â”œâ”€â”€ Validators/              # Input validation rules
â”‚   â””â”€â”€ Mappings/                # AutoMapper profiles
â”‚
â”œâ”€â”€ SecureTodo.Domain/
â”‚   â”œâ”€â”€ Entities/                # Domain models
â”‚   â””â”€â”€ Interfaces/              # Repository contracts
â”‚
â”œâ”€â”€ SecureTodo.Infrastructure/
â”‚   â”œâ”€â”€ Data/
â”‚   â”‚   â”œâ”€â”€ ApplicationDbContext.cs
â”‚   â”‚   â”œâ”€â”€ Configurations/      # EF Core configurations
â”‚   â”‚   â””â”€â”€ Migrations/          # Database migrations
â”‚   â”œâ”€â”€ Repositories/            # Data access implementations
â”‚   â””â”€â”€ Security/                # Encryption, hashing, password services
â”‚
â””â”€â”€ SecureTodo.Shared/
    â”œâ”€â”€ Constants/               # Application constants
    â”œâ”€â”€ Results/                 # Result pattern classes
    â””â”€â”€ Exceptions/              # Custom exceptions
```

## ğŸ”’ Security Best Practices

### In Development
- Use user secrets for sensitive data
- Never commit keys to version control
- Use development-specific keys
- Enable detailed error messages

### In Production
- Use Azure Key Vault or AWS Secrets Manager
- Enable HTTPS only
- Set `secure: true` for cookies
- Disable Swagger UI
- Use environment-specific configurations
- Implement proper logging (no sensitive data)
- Enable rate limiting
- Use strong encryption keys
- Rotate keys regularly
- Implement audit logging
- Use parameterized queries (EF Core does this by default)
- Validate all inputs
- Sanitize outputs
- Keep dependencies updated

## ğŸ“ License

ISC License - Free for educational and commercial use.

## ğŸ†˜ Support

For issues:
1. Check this README's troubleshooting section
2. Review logs in `Logs/` directory
3. Check Swagger UI for API documentation
4. Verify all configuration values are set
5. Ensure database is accessible

## ğŸ™ Acknowledgments

- Original Node.js implementation team
- .NET Team for ASP.NET Core 8.0
- Entity Framework Core team
- BCrypt.Net-Next contributors
- FluentValidation team
- Serilog contributors

---

**Built with â¤ï¸ demonstrating enterprise .NET security practices**
