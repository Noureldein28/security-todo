# üîí Secure Todo Application

A full-stack todo application demonstrating enterprise-grade security practices including AES-256-GCM encryption, SHA-256 integrity verification, JWT authentication, and Google OAuth SSO.

## üìã Table of Contents

- [Features](#features)
- [Security Implementation](#security-implementation)
- [Prerequisites](#prerequisites)
- [Installation](#installation)
- [Environment Configuration](#environment-configuration)
- [Running the Application](#running-the-application)
- [API Documentation](#api-documentation)
- [Testing](#testing)
- [Production Considerations](#production-considerations)
- [Troubleshooting](#troubleshooting)

## ‚ú® Features

- **User Authentication**
  - Email/password registration and login
  - Google OAuth 2.0 Single Sign-On (SSO)
  - JWT-based authentication with refresh tokens
  - HTTP-only secure cookies

- **Todo Management**
  - Create, read, update, and delete todos
  - All todo content is encrypted at rest
  - Integrity verification on every read operation

- **Security Features**
  - AES-256-GCM encryption for data at rest
  - SHA-256 integrity hashing
  - bcrypt password hashing (12 rounds)
  - Rate limiting (DoS protection)
  - Input validation and sanitization
  - XSS protection
  - NoSQL injection prevention
  - Comprehensive security logging
  - Secure headers with Helmet.js

## üîê Security Implementation

### 1. AES-256-GCM Encryption (4 points)

**How it works:**
- Each todo's content is encrypted using AES-256-GCM before storage
- **Algorithm:** AES (Advanced Encryption Standard) with 256-bit key
- **Mode:** GCM (Galois/Counter Mode) - provides both encryption and authentication
- **Key:** 32 bytes (256 bits), stored in environment variable, base64 encoded
- **IV (Initialization Vector):** 12 bytes, randomly generated per encryption, never reused
- **Auth Tag:** 16 bytes, automatically generated by GCM mode, verifies authenticity

**Storage format:**
```javascript
{
  encryptedContent: "base64-encoded-ciphertext",
  iv: "base64-encoded-12-byte-iv",
  authTag: "base64-encoded-16-byte-auth-tag",
  integrityHash: "sha256-hex-hash-of-plaintext"
}
```

**Why GCM mode?**
- Provides authenticated encryption (AEAD - Authenticated Encryption with Associated Data)
- Detects tampering automatically
- Better performance than CBC + HMAC
- Industry standard for modern encryption

**Code location:** `utils/crypto.js`

### 2. SHA-256 Integrity Verification

**How it works:**
- Before encryption: Compute SHA-256 hash of plaintext ‚Üí Store hash
- After decryption: Compute SHA-256 hash of decrypted text ‚Üí Compare with stored hash
- If hashes don't match ‚Üí Content was tampered with ‚Üí Display warning, don't show content

**Purpose:**
- Double-layer integrity check (GCM auth tag + SHA-256 hash)
- Detects database manipulation or corruption
- Provides audit trail of tampering attempts

**Code location:** `utils/hash.js`

### 3. bcrypt Password Hashing

**Configuration:**
- **Rounds:** 12 (as specified in requirements)
- **Salt:** Automatically generated per password
- **Algorithm:** bcrypt with automatic salt generation

**Code location:** `models/User.js` (pre-save hook)

### 4. JWT Authentication (2 points)

**Token Structure:**
- **Access Token:** 1 hour expiry, used for API authentication
- **Refresh Token:** 7 days expiry, used to obtain new access tokens
- **Storage:** HTTP-only cookies (prevents XSS) + Authorization header fallback
- **Secret:** Loaded from environment variable (minimum 256 bits recommended)

**Token Flow:**
```
1. User logs in ‚Üí Server issues Access + Refresh tokens
2. Client stores tokens in HTTP-only cookie (set by server)
3. Every API request includes cookie automatically
4. Server verifies token signature and expiry
5. If access token expires ‚Üí Use refresh token to get new access token
```

**Code location:** `middleware/auth.js`

### 5. Google OAuth SSO (2 points)

**Implementation:**
- Uses Passport.js with Google OAuth 2.0 strategy
- Automatically links Google accounts to existing email accounts
- Issues JWT after successful Google authentication
- No password required for Google users

**Setup Instructions:** See [Google OAuth Setup](#google-oauth-setup)

**Code location:** `config/passport.js`, `controllers/authController.js`

### 6. Secure Coding Practices (2 points)

#### a) DoS Protection (Rate Limiting)
- **General Endpoints:** 60 requests/minute per IP
- **Auth Endpoints:** 10 requests/minute per IP (stricter)
- **Implementation:** express-rate-limit middleware

#### b) NoSQL Injection Prevention
- **Validation:** express-validator on all inputs
- **Sanitization:** Input types validated (strings, numbers, ObjectIds)
- **Mongoose:** Parameterized queries (built-in protection)

#### c) XSS Prevention
- **Server-side:** Input sanitization with express-validator
- **Client-side:** Using `textContent` instead of `innerHTML`
- **Headers:** Content Security Policy via Helmet.js

#### d) Logging
- **Framework:** Winston logger
- **What's logged:** Login attempts, security events, errors
- **What's NOT logged:** Passwords, tokens, encryption keys
- **Location:** `logs/` directory

**Code locations:** `middleware/rateLimiter.js`, `middleware/validation.js`, `utils/logger.js`

## üì¶ Prerequisites

- **Node.js:** Version 16 or higher ([Download](https://nodejs.org/))
- **MongoDB:** Local installation OR MongoDB Atlas account
- **Google OAuth Credentials:** (Optional, for SSO feature)

## üöÄ Installation

### Step 1: Clone or Download the Project

If you received this as a zip file, extract it. Otherwise:

```bash
cd path/to/Secure_app
```

### Step 2: Install Dependencies

```bash
npm install
```

This will install all required packages listed in `package.json`.

## ‚öôÔ∏è Environment Configuration

### Step 1: Create .env File

Copy the example environment file:

```bash
copy .env.example .env
```

### Step 2: Generate Encryption Keys

#### Generate AES-256 Key (32 bytes)

**Option 1 - Using OpenSSL (Windows Git Bash, Linux, macOS):**
```bash
openssl rand -base64 32
```

**Option 2 - Using Node.js (Windows CMD/PowerShell):**
```bash
node -e "console.log(require('crypto').randomBytes(32).toString('base64'))"
```

Copy the output and paste it as the `AES_KEY` value in `.env`.

#### Generate JWT Secret

```bash
node -e "console.log(require('crypto').randomBytes(64).toString('base64'))"
```

Copy the output and paste it as `JWT_SECRET` in `.env`.

#### Generate JWT Refresh Secret

```bash
node -e "console.log(require('crypto').randomBytes(64).toString('base64'))"
```

Copy the output and paste it as `JWT_REFRESH_SECRET` in `.env`.

### Step 3: Configure MongoDB

#### Option A: Local MongoDB

1. Install MongoDB Community Server from [mongodb.com/download](https://www.mongodb.com/try/download/community)
2. Start MongoDB service:
   - **Windows:** MongoDB should start automatically, or run `net start MongoDB`
   - **macOS:** `brew services start mongodb-community`
   - **Linux:** `sudo systemctl start mongod`

3. In `.env`, set:
   ```
   MONGODB_URI=mongodb://localhost:27017/secure_todo_db
   ```

#### Option B: MongoDB Atlas (Cloud)

1. Go to [mongodb.com/atlas](https://www.mongodb.com/cloud/atlas) and create a free account
2. Create a new cluster (free tier M0)
3. Click "Connect" ‚Üí "Connect your application"
4. Copy the connection string
5. Replace `<password>` with your database user password
6. In `.env`, set:
   ```
   MONGODB_URI=mongodb+srv://username:password@cluster0.xxxxx.mongodb.net/secure_todo_db?retryWrites=true&w=majority
   ```

### Step 4: Google OAuth Setup (Optional)

If you want to enable Google Sign-In:

1. Go to [Google Cloud Console](https://console.cloud.google.com/)
2. Create a new project or select existing one
3. Enable "Google+ API"
4. Go to "Credentials" ‚Üí "Create Credentials" ‚Üí "OAuth 2.0 Client ID"
5. Configure OAuth consent screen (add your email as test user)
6. Create OAuth Client ID:
   - Application type: Web application
   - Authorized redirect URIs: `http://localhost:4000/api/auth/google/callback`
7. Copy Client ID and Client Secret to `.env`:
   ```
   GOOGLE_CLIENT_ID=your-client-id.apps.googleusercontent.com
   GOOGLE_CLIENT_SECRET=your-client-secret
   ```

### Example Complete .env File

```env
PORT=4000
NODE_ENV=development

MONGODB_URI=mongodb://localhost:27017/secure_todo_db

JWT_SECRET=YourGeneratedBase64SecretHere==
JWT_EXPIRES_IN=1h
JWT_REFRESH_SECRET=YourGeneratedRefreshSecretHere==
JWT_REFRESH_EXPIRES_IN=7d

AES_KEY=YourGenerated32ByteKeyInBase64==

GOOGLE_CLIENT_ID=123456789-abcdefg.apps.googleusercontent.com
GOOGLE_CLIENT_SECRET=GOCSPX-your_secret_here

FRONTEND_URL=http://localhost:4000
```

## üéØ Running the Application

### Development Mode (with auto-restart)

```bash
npm run dev
```

### Production Mode

```bash
npm start
```

### Access the Application

Open your browser and navigate to:
```
http://localhost:4000
```

You should see the login/register page.

## üìö API Documentation

### Authentication Endpoints

#### Register User
```http
POST /api/auth/register
Content-Type: application/json

{
  "username": "johndoe",
  "email": "john@example.com",
  "password": "SecurePass123"
}
```

**Response:**
```json
{
  "message": "User registered successfully",
  "user": {
    "id": "...",
    "email": "john@example.com",
    "username": "johndoe"
  },
  "accessToken": "eyJhbGc...",
  "refreshToken": "eyJhbGc..."
}
```

#### Login
```http
POST /api/auth/login
Content-Type: application/json

{
  "email": "john@example.com",
  "password": "SecurePass123"
}
```

#### Google OAuth
```http
GET /api/auth/google
```
Redirects to Google sign-in page.

#### Refresh Token
```http
POST /api/auth/refresh
Content-Type: application/json

{
  "refreshToken": "your-refresh-token"
}
```

#### Logout
```http
POST /api/auth/logout
```

### Todo Endpoints (Require Authentication)

All todo endpoints require a valid JWT token in the `Authorization` header or HTTP-only cookie.

#### Get All Todos
```http
GET /api/todos
Authorization: Bearer your-jwt-token
```

**Response:**
```json
{
  "todos": [
    {
      "id": "...",
      "content": "Buy groceries",
      "tampered": false,
      "createdAt": "2023-01-01T00:00:00.000Z",
      "updatedAt": "2023-01-01T00:00:00.000Z"
    }
  ]
}
```

If a todo's integrity check fails:
```json
{
  "id": "...",
  "content": "[INTEGRITY VIOLATION - Content may have been tampered with]",
  "tampered": true,
  "createdAt": "...",
  "updatedAt": "..."
}
```

#### Create Todo
```http
POST /api/todos
Authorization: Bearer your-jwt-token
Content-Type: application/json

{
  "content": "Buy groceries"
}
```

#### Update Todo
```http
PUT /api/todos/:id
Authorization: Bearer your-jwt-token
Content-Type: application/json

{
  "content": "Buy groceries and cook dinner"
}
```

#### Delete Todo
```http
DELETE /api/todos/:id
Authorization: Bearer your-jwt-token
```

## üß™ Testing

### Manual Testing with curl

#### 1. Register a User
```bash
curl -X POST http://localhost:4000/api/auth/register ^
  -H "Content-Type: application/json" ^
  -d "{\"username\":\"testuser\",\"email\":\"test@example.com\",\"password\":\"Test1234\"}"
```

Save the `accessToken` from the response.

#### 2. Create a Todo
```bash
curl -X POST http://localhost:4000/api/todos ^
  -H "Content-Type: application/json" ^
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" ^
  -d "{\"content\":\"My first secure todo\"}"
```

#### 3. Get All Todos
```bash
curl -X GET http://localhost:4000/api/todos ^
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

#### 4. Simulate Integrity Failure

To demonstrate integrity verification:

1. Use MongoDB Compass or mongosh to connect to your database
2. Find a todo document
3. Manually change the `encryptedContent` field (change one character)
4. Fetch todos via API - you'll see `[INTEGRITY VIOLATION...]` message

**Using mongosh:**
```javascript
use secure_todo_db
db.todos.updateOne(
  {}, 
  { $set: { encryptedContent: "tampered_data" } }
)
```

Then fetch todos again - the tampered todo will be flagged.

### Testing Rate Limiting

Try making more than 10 login requests within 1 minute:

```bash
for i in {1..15}; do curl -X POST http://localhost:4000/api/auth/login -H "Content-Type: application/json" -d "{\"email\":\"test@test.com\",\"password\":\"test\"}"; done
```

After 10 requests, you should receive a 429 (Too Many Requests) response.

### Testing XSS Prevention

Try creating a todo with HTML/JavaScript:

```bash
curl -X POST http://localhost:4000/api/todos ^
  -H "Content-Type: application/json" ^
  -H "Authorization: Bearer YOUR_TOKEN" ^
  -d "{\"content\":\"<script>alert('XSS')</script>\"}"
```

The content will be escaped and displayed as plain text in the UI.

## üè≠ Production Considerations

### Critical Security Enhancements for Production

1. **HTTPS/TLS**
   - Use proper TLS certificates (Let's Encrypt)
   - Enforce HTTPS redirect
   - Set `secure: true` in cookie configuration

2. **Key Management**
   - Use AWS KMS, Azure Key Vault, or HashiCorp Vault
   - Rotate encryption keys periodically
   - Never store keys in source code or version control

3. **Database Security**
   - Enable MongoDB authentication
   - Use network IP whitelisting
   - Enable encryption at rest
   - Regular backups

4. **Environment Variables**
   - Use secret management services (AWS Secrets Manager, etc.)
   - Different keys for dev/staging/production
   - Audit access to secrets

5. **Monitoring & Logging**
   - Centralized logging (ELK stack, CloudWatch)
   - Real-time alerts for security events
   - Log rotation and retention policies

6. **Authentication**
   - Implement account lockout after failed attempts
   - Add 2FA/MFA support
   - Password complexity requirements
   - Session management and timeout

7. **Rate Limiting**
   - Use Redis for distributed rate limiting
   - More granular limits per endpoint
   - IP reputation checking

8. **Additional Headers**
   - Strict-Transport-Security (HSTS)
   - X-Frame-Options
   - X-Content-Type-Options

9. **Code Security**
   - Regular dependency updates (`npm audit`)
   - Static code analysis (ESLint security plugins)
   - Penetration testing

10. **Backup & Recovery**
    - Automated database backups
    - Disaster recovery plan
    - Key recovery procedures

### Performance Optimizations

- Implement caching (Redis)
- Database indexing (already implemented)
- CDN for static assets
- Horizontal scaling with load balancer
- Database connection pooling

## üîß Troubleshooting

### "AES_KEY environment variable is not set"

**Solution:** Make sure you created the `.env` file and generated the AES key:
```bash
node -e "console.log(require('crypto').randomBytes(32).toString('base64'))"
```

### "MongoDB connection failed"

**Solution:** 
- Check MongoDB is running: `net start MongoDB` (Windows)
- Verify MONGODB_URI in `.env`
- Check MongoDB Atlas whitelist if using cloud

### "Invalid token" errors

**Solution:**
- Token may have expired (1 hour default)
- Use refresh token to get new access token
- Clear cookies and login again

### Google OAuth not working

**Solution:**
- Verify redirect URI matches exactly: `http://localhost:4000/api/auth/google/callback`
- Check Google Client ID and Secret in `.env`
- Make sure OAuth consent screen is configured

### Port 4000 already in use

**Solution:** Change the PORT in `.env` or kill the process using port 4000:
```bash
# Windows
netstat -ano | findstr :4000
taskkill /PID <PID> /F

# Linux/Mac
lsof -ti:4000 | xargs kill -9
```

### Todos showing "[DECRYPTION FAILED]"

**Solution:**
- AES_KEY may have changed
- Database was manually edited
- Re-generate the key and re-create todos

## üìù Project Structure

```
Secure_app/
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îî‚îÄ‚îÄ passport.js          # Google OAuth configuration
‚îú‚îÄ‚îÄ controllers/
‚îÇ   ‚îú‚îÄ‚îÄ authController.js    # Authentication logic
‚îÇ   ‚îî‚îÄ‚îÄ todoController.js    # Todo CRUD logic
‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îú‚îÄ‚îÄ auth.js              # JWT verification
‚îÇ   ‚îú‚îÄ‚îÄ rateLimiter.js       # DoS protection
‚îÇ   ‚îî‚îÄ‚îÄ validation.js        # Input validation
‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îú‚îÄ‚îÄ User.js              # User schema with bcrypt
‚îÇ   ‚îî‚îÄ‚îÄ Todo.js              # Todo schema (encrypted)
‚îú‚îÄ‚îÄ public/
‚îÇ   ‚îú‚îÄ‚îÄ css/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ style.css        # Frontend styles
‚îÇ   ‚îú‚îÄ‚îÄ js/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ app.js           # Frontend JavaScript
‚îÇ   ‚îî‚îÄ‚îÄ index.html           # Main HTML page
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îú‚îÄ‚îÄ authRoutes.js        # Auth endpoints
‚îÇ   ‚îî‚îÄ‚îÄ todoRoutes.js        # Todo endpoints
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îú‚îÄ‚îÄ crypto.js            # AES-256-GCM encryption
‚îÇ   ‚îú‚îÄ‚îÄ hash.js              # SHA-256 integrity
‚îÇ   ‚îî‚îÄ‚îÄ logger.js            # Winston logging
‚îú‚îÄ‚îÄ logs/                    # Log files (auto-created)
‚îú‚îÄ‚îÄ .env                     # Environment variables (create this)
‚îú‚îÄ‚îÄ .env.example             # Example env file
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ server.js                # Main server file
‚îî‚îÄ‚îÄ README.md                # This file
```

## üéì Security Concepts Explained

### Why HTTP-only Cookies vs localStorage?

**HTTP-only Cookies (Recommended):**
- ‚úÖ JavaScript cannot access (XSS protection)
- ‚úÖ Automatically sent with requests
- ‚úÖ Can be marked as Secure (HTTPS-only)
- ‚ùå Vulnerable to CSRF (mitigated with SameSite)

**localStorage:**
- ‚ùå Accessible by JavaScript (XSS risk)
- ‚úÖ Not sent automatically (manual inclusion)
- ‚úÖ Not vulnerable to CSRF
- ‚ùå Persists across sessions unless cleared

**Our Implementation:** We use HTTP-only cookies as the primary method (more secure) but also return the token in the response body for flexibility.

### AES-256-GCM Explained

**Symmetric Encryption:** Same key for encryption and decryption.

**Process:**
1. **Encryption:**
   ```
   Plaintext + Key + IV ‚Üí Cipher ‚Üí Ciphertext + AuthTag
   ```

2. **Decryption:**
   ```
   Ciphertext + Key + IV + AuthTag ‚Üí Decipher ‚Üí Plaintext
   ```

**Why unique IV?**
- Reusing IV with same key breaks security
- We generate random 12-byte IV per encryption
- IV stored alongside ciphertext (not secret)

**AuthTag purpose:**
- Proves ciphertext wasn't modified
- Automatically verified during decryption
- If tampered ‚Üí decryption throws error

## üìÑ License

ISC License - Free for educational and commercial use.

## üë• Team Questions

See `questions.md` for individual team member questions and answers.

## üÜò Support

If you encounter issues:

1. Check this README's troubleshooting section
2. Verify all environment variables are set correctly
3. Check the console logs for error messages
4. Review logs in the `logs/` directory

---

**Built with ‚ù§Ô∏è demonstrating enterprise security practices**
